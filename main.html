<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Phaser 3 – Minimal Controller Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Phaser CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; background:#0f1220; }
    #game { width: 100%; height: 100%; }
    .hint {
      position: fixed; left: 12px; bottom: 12px; color: #d6d6ff; font-family: system-ui, sans-serif;
      font-size: 12px; opacity: .8; user-select: none; letter-spacing:.2px
    }
  </style>
</head>
<body>
  <div id="game"></div>
  <div class="hint">Move: ← → / A D &nbsp;·&nbsp; Jump: ↑ / W / Space</div>
  <script>
    // --- Game config ---
    const config = {
      type: Phaser.AUTO,
      parent: 'game',
      backgroundColor: '#11131f',
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: 960,
        height: 540
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 1400 },
          debug: false
        }
      },
      scene: { preload, create, update }
    };

    let cursors, keys, player, platforms, lastOnGround = true;

    new Phaser.Game(config);

    function preload() {
      // Build simple textures at runtime (no assets needed)
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      // Player texture (rounded rectangle)
      g.fillStyle(0x5ac8fa, 1);
      roundedRect(g, 0, 0, 36, 52, 10);
      g.generateTexture('player', 36, 52);
      g.clear();
      // Ground block
      g.fillStyle(0x3b3f66, 1);
      g.fillRect(0, 0, 128, 32);
      g.generateTexture('ground', 128, 32);
      g.destroy();
    }

    function create() {
      // Level: a few platforms
      platforms = this.physics.add.staticGroup();
      const W = this.scale.width, H = this.scale.height;

      // Floor line
      for (let x = -256; x < 2000; x += 128) platforms.create(x, H - 16, 'ground').setOrigin(0, 0.5);
      // Floating platforms
      platforms.create(200, H - 160, 'ground');
      platforms.create(420, H - 260, 'ground');
      platforms.create(700, H - 340, 'ground');
      platforms.create(980, H - 260, 'ground').setScale(1.2, 1).refreshBody();

      // Player
      player = this.physics.add.sprite(120, H - 120, 'player');
      player.setCollideWorldBounds(false); // world is wider than viewport
      player.setDragX(900);
      player.setMaxVelocity(460, 1200);
      player.setBounce(0.0);
      player.body.setSize(28, 50).setOffset(4, 2); // tighter hitbox

      this.physics.add.collider(player, platforms);

      // Camera setup
      this.cameras.main.setBounds(-300, 0, 2200, H);
      this.cameras.main.startFollow(player, true, 0.12, 0.12);
      this.cameras.main.setZoom(1.1);

      // Controls
      cursors = this.input.keyboard.createCursorKeys();
      keys = this.input.keyboard.addKeys({
        W: Phaser.Input.Keyboard.KeyCodes.W,
        A: Phaser.Input.Keyboard.KeyCodes.A,
        S: Phaser.Input.Keyboard.KeyCodes.S,
        D: Phaser.Input.Keyboard.KeyCodes.D
      });

      // Double-jump / coyote-time helpers
      player.canDouble = true;
      player.coyoteMs = 110;
      player.jumpBufferMs = 120;
      player.timeLeftGround = 0;
      player.timeJumpPressed = 0;

      // Track jump key buffering
      this.input.keyboard.on('keydown', e => {
        if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
          player.timeJumpPressed = this.time.now;
        }
      });

      // Resize handler to keep floor in view
      this.scale.on('resize', (size) => {
        this.cameras.main.setBounds(-300, 0, 2200, size.height);
      });
    }

    function update(time, delta) {
      const onGround = player.body.blocked.down || player.body.touching.down;
      const left  = cursors.left.isDown || keys.A.isDown;
      const right = cursors.right.isDown || keys.D.isDown;
      const jumpPressed = Phaser.Input.Keyboard.JustDown(cursors.up) ||
                          Phaser.Input.Keyboard.JustDown(keys.W) ||
                          Phaser.Input.Keyboard.JustDown(cursors.space);

      // Track coyote time (short grace after leaving ground)
      if (onGround) {
        player.timeLeftGround = time;
        player.canDouble = true;
      } else if (lastOnGround && !onGround) {
        player.timeLeftGround = time; // just left ground
      }
      lastOnGround = onGround;

      // Horizontal movement
      const runAccel = 1800;
      if (left && !right) {
        player.setAccelerationX(-runAccel);
        player.setFlipX(true);
      } else if (right && !left) {
        player.setAccelerationX(runAccel);
        player.setFlipX(false);
      } else {
        player.setAccelerationX(0);
      }

      // Buffered jump + coyote time
      const canCoyote = (time - player.timeLeftGround) <= player.coyoteMs;
      const buffered = (time - player.timeJumpPressed) <= player.jumpBufferMs;

      if ((jumpPressed || buffered) && (onGround || canCoyote)) {
        doJump(player);
        player.timeJumpPressed = -Infinity; // consume buffer
      } else if (jumpPressed && player.canDouble && !onGround && !canCoyote) {
        doJump(player, true); // double jump
        player.canDouble = false;
      }

      // Variable jump height (release early to cut velocity)
      if (!(cursors.up.isDown || keys.W.isDown || cursors.space.isDown) && player.body.velocity.y < 0) {
        player.setVelocityY(player.body.velocity.y * 0.6);
      }

      // Simple "squash & stretch" visual feedback
      const speedX = Math.abs(player.body.velocity.x);
      const scaleX = Phaser.Math.Clamp(1 + (speedX / 900) * 0.06, 1, 1.08);
      const scaleY = 1 / scaleX;
      player.setScale(scaleX, scaleY);
      if (onGround) player.setTint(0x5ac8fa); else player.setTint(0x7fd3ff);
    }

    function doJump(sprite, isDouble = false) {
      const base = 520;
      sprite.setVelocityY(-base);
      // brief squash
      sprite.scene.tweens.add({
        targets: sprite,
        scaleY: 1.15,
        scaleX: 0.92,
        duration: 70,
        yoyo: true,
        ease: 'Quad.easeOut'
      });
      if (isDouble) {
        flash(sprite, 90);
      } else {
        flash(sprite, 40);
      }
    }

    // Small visual flash on jump
    function flash(sprite, duration) {
      const cam = sprite.scene.cameras.main;
      cam.flash(duration, 255, 255, 255, false);
    }

    // Utility to draw rounded rectangles
    function roundedRect(g, x, y, w, h, r) {
      g.fillRoundedRect(x, y, w, h, r);
    }
  </script>
</body>
</html>
